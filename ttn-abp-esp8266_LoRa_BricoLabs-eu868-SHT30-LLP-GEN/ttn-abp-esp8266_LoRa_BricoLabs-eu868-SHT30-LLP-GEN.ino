/**********************************************************************************************************
 * The Things Network - ABP WemosD1 Mini + LoRa Shield BricoLabs + SHT30 Shield (based on Adafruit example)
 * 
 * Example of using an ESP8266 +LoRa Shield BricoLabs + SHT30 v1.0 Wemos Shield
 * Single-channel TTN gateway used & installed in another HW (ESP8266 or ESP32):
 * https://github.com/things4u/ESP-1ch-Gateway-v5.0
 * 
 * This uses ABP (Activation by Personalization), where session keys for
 * communication would be assigned/generated by TTN and hard-coded on the device.
 * 
 * Learn Guide: https://learn.adafruit.com/the-things-network-for-feather
 * 
 * @AlexCorvis84 2019
 * 
 * Github Repository: https://github.com/alexcorvis84/LoRa_MakersAsturias
 * 
 * Copyright (c) 2015 Thomas Telkamp and Matthijs Kooijman
 * Copyright (c) 2018 Terry Moore, MCCI
 * Copyright (c) 2018 Brent Rubell, Adafruit Industries
 * Copyright (c) 2019 Alex Corvis (@AlexCorvis84)
 * 
 * Permission is hereby granted, free of charge, to anyone
 * obtaining a copy of this document and accompanying files,
 * to do whatever they want with them without any restriction,
 * including, but not limited to, copying, modification and redistribution.
 * NO WARRANTY OF ANY KIND IS PROVIDED.
 *
 * ESP8266 BricoLabs Shield Pinout:
 * 
ESP8266        LoRa (SPI)      Display (I2C)  LED
-----------    ----------      -------------  ------------------
GPIO14 D5      SCK
GPIO13 D7      MOSI
GPIO12 D6      MISO
GPIO15 D8      NSS
GPIO16 D0      RST
GPIO0  D3      DIO0
GPIO4  D2      DIO1           SDA (SHT30)
GPIO5  D1                     SCL (SHT30)
GPIO2  D4                                      BUILTIN_LED
*
* JP1 can be connected to RST or DIO2 -> D0
* 
* +INFO Schematic PCB: 
* https://github.com/brico-labs/LoRa/blob/master/WorkshopOSHWDem18/BricoLabs_ESP8266_LoRa_shield/BricoLabs_ESP8266_LoRa_shield-Schematic.pdf
*
* The LMIC library used is the Arduino-lmic one: 
* https://github.com/matthijskooijman/arduino-lmic
*
***********************************************************************************************************/
#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>
#include <CayenneLPP.h>

// Include the SHT30 Sensor Library
#include <WEMOS_SHT3X.h>
SHT3X sht30(0x45);

#define LEDPIN 2 // Programmable Blue LED BUILTIN
int channel = 0;

CayenneLPP lpp(51); //Cayenne instance with recommended 51 bytes of payload


// LoRaWAN NwkSKey, network session key
static const PROGMEM u1_t NWKSKEY[16] = {  };

// LoRaWAN AppSKey, application session key
static const u1_t PROGMEM APPSKEY[16] = {  };

// LoRaWAN end-device address (DevAddr)
// See http://thethingsnetwork.org/wiki/AddressSpace
// The library converts the address to network byte order as needed.

static const u4_t DEVADDR = 0x00000000;

// These callbacks are only used in over-the-air activation, so they are
// left empty here (we cannot leave them out completely unless
// DISABLE_JOIN is set in arduino-lmic/project_config/lmic_project_config.h,
// otherwise the linker will complain).
void os_getArtEui (u1_t* buf) { }
void os_getDevEui (u1_t* buf) { }
void os_getDevKey (u1_t* buf) { }

static osjob_t sendjob;

// Schedule TX every this many seconds (might become longer due to duty
// cycle limitations).
const unsigned TX_INTERVAL = 30;

// Pin mapping for for BricoLoRa Shield
const lmic_pinmap lmic_pins = {
    .nss = D8,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = LMIC_UNUSED_PIN, //JP1 needs to be shorted to D0. Not needed though
    .dio = {LMIC_UNUSED_PIN, LMIC_UNUSED_PIN, LMIC_UNUSED_PIN},
};


void onEvent (ev_t ev) {
    Serial.print("Hora: ");
    Serial.print(os_getTime());
    Serial.print("\nDevice Address: ");
    Serial.print(LMIC.devaddr);
    
    switch(ev) {
        case EV_SCAN_TIMEOUT:
            Serial.println(F("\nEV_SCAN_TIMEOUT"));
            break;
        case EV_BEACON_FOUND:
            Serial.println(F("\nEV_BEACON_FOUND"));
            break;
        case EV_BEACON_MISSED:
            Serial.println(F("\nEV_BEACON_MISSED"));
            break;
        case EV_BEACON_TRACKED:
            Serial.println(F("\nEV_BEACON_TRACKED"));
            break;
        case EV_JOINING:
            Serial.println(F("\nEV_JOINING"));
            break;
        case EV_JOINED:
            Serial.println(F("\nEV_JOINED"));
            break;
        case EV_JOIN_FAILED:
            Serial.println(F("\nEV_JOIN_FAILED"));
            break;
        case EV_REJOIN_FAILED:
            Serial.println(F("\nEV_REJOIN_FAILED"));
            break;
        case EV_TXCOMPLETE:
            Serial.println(F("\nEV_TXCOMPLETE (includes waiting for RX windows)"));
            
            if (LMIC.txrxFlags & TXRX_ACK)
              Serial.println(F("\nRECEIVED ACK"));
            
            if (LMIC.dataLen) {
              Serial.println(F("Received "));
              Serial.println(LMIC.dataLen);
              Serial.println(F(" bytes of payload"));
              Serial.print("\nRSSI: ");
              Serial.print(LMIC.rssi);
              Serial.print("\nSNR: ");
              Serial.print(LMIC.snr);
            }
            
            // Schedule next transmission
            os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
            break;
            
        case EV_LOST_TSYNC:
            Serial.println(F("EV_LOST_TSYNC"));
            break;
        case EV_RESET:
            Serial.println(F("EV_RESET"));
            break;
        case EV_RXCOMPLETE:
            // data received in ping slot
            Serial.println(F("EV_RXCOMPLETE"));
            break;
        case EV_LINK_DEAD:
            Serial.println(F("EV_LINK_DEAD"));
            break;
        case EV_LINK_ALIVE:
            Serial.println(F("EV_LINK_ALIVE"));
            break;
        /*
        || This event is defined but not used in the code. No
        || point in wasting codespace on it.
        ||
        || case EV_SCAN_FOUND:
        ||    Serial.println(F("EV_SCAN_FOUND"));
        ||    break;
        */
        /*case EV_TXSTART:
            Serial.println(F("EV_TXSTART"));
            break;*/
        default:
            Serial.print(F("Unknown event: "));
            Serial.println((unsigned) ev);
            break;
    }
}

void do_send(osjob_t* j){
    // Check if there is not a current TX/RX job running
    if (LMIC.opmode & OP_TXRXPEND) {
        Serial.println(F("OP_TXRXPEND, not sending"));
        
    } else {
        // read the temperature from the SHT30
        sht30.get();
        float temperature = sht30.cTemp;
        Serial.print("Temperature: "); 
        Serial.print(temperature);
        Serial.println(" *C");      
        // read the humidity from the DHT22
        float rHumidity = sht30.humidity; 
        Serial.print("Relative Humidity: ");
        Serial.print(rHumidity);
        Serial.println(" %RH ");
        
		    lpp.reset();
		    lpp.addTemperature(1, temperature);
		    lpp.addRelativeHumidity(2, rHumidity);

        // prepare upstream data transmission at the next possible time.
        // transmit on port 1 (the first parameter); you can use any value from 1 to 223 (others are reserved).
        // don't request an ack (the last parameter, if not zero, requests an ack from the network).
        // Remember, acks consume a lot of network resources; don't ask for an ack unless you really need it.
        digitalWrite(LEDPIN, LOW);
        delay(1000);
        LMIC_setTxData2(1, lpp.getBuffer(), lpp.getSize(), 0);
        digitalWrite(LEDPIN,HIGH);
        
        Serial.println (F ("Packet queued"));     
    }
    // Next TX is scheduled after TX_COMPLETE event.
}

void setup() {

    Serial.begin(115200);
    Serial.println(".....");
    Serial.println(F("Starting"));
    pinMode(LEDPIN, OUTPUT);

    // LMIC init
	  Serial.println("Inicializado Radio LORA");
    os_init();
    // Reset the MAC state. Session and pending data transfers will be discarded.
    LMIC_reset();

    // Set static session parameters. Instead of dynamically establishing a session
    // by joining the network, precomputed session parameters are be provided.
    #ifdef PROGMEM
    // On AVR, these values are stored in flash and only copied to RAM
    // once. Copy them to a temporary buffer here, LMIC_setSession will
    // copy them into a buffer of its own again.
    uint8_t appskey[sizeof(APPSKEY)];
    uint8_t nwkskey[sizeof(NWKSKEY)];
    memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));
    memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));
    LMIC_setSession (0x13, DEVADDR, nwkskey, appskey);
    #else
    // If not running an AVR with PROGMEM, just use the arrays directly
    LMIC_setSession (0x13, DEVADDR, NWKSKEY, APPSKEY);
    #endif

    #if defined(CFG_eu868)
    // We'll only enable Channel 0 (868.1Mhz) since we're transmitting on a single-channel
    LMIC_setupChannel (0, 868100000, DR_RANGE_MAP(DR_SF12, DR_SF7), BAND_CENTI);
    LMIC_setupChannel (1, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (2, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (3, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (4, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (5, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (6, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (7, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g-band
    LMIC_setupChannel (8, 868100000, DR_RANGE_MAP (DR_SF12, DR_SF7), BAND_CENTI);      // g2-band
    #endif
    
    // We'll disable all 9 channels used by TTN
	  for(int i=0; i<9; i++) { // For EU; for US use i<71
        if(i != channel) {
            LMIC_disableChannel(i);
        }
    }
    
    //LMIC_enableChannel(channel);
    LMIC.txChnl=channel;

    // Disable link check validation
    LMIC_setLinkCheckMode(0);

    // TTN uses SF9 for its RX2 window.
	// https://github.com/mcci-catena/arduino-lmic#downlink-datarate
    LMIC.dn2Dr = DR_SF9;

    // Set data rate and transmit power for uplink (note: txpow seems to be ignored by the library)
    LMIC_setDrTxpow(DR_SF7,14);

    // Start job
    do_send(&sendjob);
}

void loop() {
	
  os_runloop_once();  

}
